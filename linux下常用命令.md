[TOC]

记录在使用linux过程中常用的命令，方便查找

# 装机建议安装软件
```
对于centos:
yum install -y net-tools vim gcc gcc-c++ make
yum install -y psmisc sysstat
yum install -y numactl-devel*x86_64
yum install -y bzip2 bc git pciutils-devel
yum install -y elfutils-libelf-devel elfutils-devel ncurses-devel
yum install -y kernel-devel kernel-headers

对于debian:
apt-get -y install vim
apt-get -y install net-tools
apt-get -y install git make bc gcc
apt-get -y install ethtool
apt-get -y install libstdc++
apt-get -y install libpcre3 libpcre3-dev
apt-get -y install zlib1g-dev

apt-get -y install linux-headers-$(uname -r)

apt-get -y install libnuma-dev 
```
# 配置网口ip
```
对于centos:
# vim /etc/sysconfig/network-scripts/ifcfg-eth0 

BOOTPROTO="static" #dhcp改为static   
ONBOOT="yes" #开机启用本配置  
IPADDR=192.168.7.106 #静态IP  
GATEWAY=192.168.7.1 #默认网关  
NETMASK=255.255.255.0 #子网掩码  
DNS1=192.168.7.1 #DNS 配置 

# service network restart  

对于debian：
/etc/network/interfaces
auto eth0                  #设置自动启动eth0接口
iface eth0 inet static     #配置静态IP
address 192.168.11.88      #IP地址
netmask 255.255.255.0      #子网掩码
gateway 192.168.11.1        #默认网关
dns-nameservers 8.8.8.8 144.144.144.144        #DNS

```
# 禁用ipv6
```
在/etc/default/grub里面disable掉ipv6如下

[ych@localhost ~]$ cat /etc/default/grub
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_OUTPUT="console"
GRUB_CMDLINE_LINUX="ipv6.disable=1 vconsole.keymap=us crashkernel=auto  vconsole.font=latarcyrheb-sun16 rhgb quiet"
GRUB_DISABLE_RECOVERY="true"

更新grub
grub2-mkconfig -o /boot/grub2/grub.cfg

/proc/sys/net/ipv6/conf/all/disable_ipv6，0表示允许，1表示不允许
```
# 查看系统dns
```
[ych@localhost ~]$ cat /etc/resolv.conf 
# Generated by NetworkManager
domain localdomain
search localdomain
nameserver 192.168.17.2
```
# 关闭SELINUX，之后重启
```
[root@localhost selinux]# cat /etc/selinux/config

# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of these two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected. 
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted 

reboot
```
# 配置samba
```
对于centos：
sudo yum -y install nano vim wget curl net-tools lsof
sudo yum -y install samba samba-client samba-common
对于debian：
apt-get -y install samba-common-bin python-samba python-ldb python-tdb
apt-get -y install libtalloc2 samba samba-common


创建共享目录
mkdir -p /home/ych/share
ulimit -n 16384

vim /etc/security/limits.conf
在最后加入以下内容
*-nofile 16384

cat /etc/samba/smb.conf
[ych]
        comment = ych samba share
        path = /home/ych
        public = no
        writable = yes
        write list = @ych
	
创建samba用户
	smbpasswd -a ych

systemctl restart smb
systemctl enable smb

iptables -F
#停止firewall
systemctl stop firewalld.service
#禁止firewall开机启动
systemctl disable firewalld.service
#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）
firewall-cmd --state

iptables -F
systemctl stop firewalld.service
systemctl disable firewalld.service
firewall-cmd --state
```
# 设置cpu频率
```
centos与其他系统设置方法不同，需要先在 /etc/default/grub中加入  intel_pstate=disable
cpupower -c 86 frequency-set -f 2.10GHz
```
# CentOS Mini 安装图像界面
```
centos 6.5
yum groupinstall -y "Desktopp" \
"Desktop Platform" \
"Fonts" \
"General Purpose Desktop" \
"Graphical Administration Tools" \
"Input Methods" \
"Legacy X Window System compatibility" \
"Remote Desktop Clients" \
"X Window System"

CentOS7
sudo yum groupinstall "GNOME Desktop" "Graphical Administration Tools"
```
# CentOS7图形界面与命令行界面切换
```
查看当前系统启动模式
systemctl get-default

将图形化界面切换为命令行，输入命令
sudo systemctl set-default multi-user.target
sudo reboot

将命令行切换为图形化界面，输入命令
sudo systemctl set-default graphical.target
sudo reboot
```
# centos内核 下载、源码编译、修改grub启动顺序
```
下载：
进入官网下载
由上面两个步骤我们知道了自己centos版本为6.7，内核版本为2.6.32-573.el6.i686
源代码的官网：http://vault.centos.org/
进入官网后，再一次进入6.7/，进入os/，进入Source/，进入SPackages/，找到kernel-2.6.32-573.el6.src.rpm下载就行了
也可以直接在linux系统上下载，例如
wget http://vault.centos.org/7.4.1708/os/Source/SPackages/kernel-3.10.0-693.el7.src.rpm

rpm -ivh kernel-3.10.0-693.el7.src.rpm
这时会产生目录/root/rpmbuild/SPECS和/root/rpmbuild/SOURCES
rpmbuild -bp --target=$(uname -m) /root/rpmbuild/SPECS/kernel.spec

Makefile:906: "Cannot use CONFIG_STACK_VALIDATION, please install libelf-dev or elfutils-libelf-devel"

源码编译:
make -j8
make modules_install -j8
make install -j8
```
# 修改CentOS7 Grub启动顺序
```
1. 查看系统有哪些启动选项
cat /boot/grub2/grub.cfg |grep menuentry
2. 设置grub到默认的7.4 kernel 
grub2-set-default 'CentOS Linux (3.10.0-693.el7.x86_64) 7 (Core)'
grub2-set-default 'CentOS Linux (3.10.0-693.21.1.el7.x86_64) 7 (Core)'
grub2-set-default 'CentOS Linux (3.10.0) 7 (Core)'
grub2-set-default 'CentOS Linux 7 (Core), with Linux 3.10.0-327.el7.x86_64'
grub2-set-default 'CentOS Linux (3.16.56) 7 (Core)'
grub2-set-default 'CentOS Linux 7 (Core), with Linux 3.10.0-229.el7.x86_64'
grub2-set-default 'NeoKylin Desktop (3.10.0) 7.0 (Seven)'
grub2-set-default 'CentOS Linux (3.10.0) 7 (Core)'
grub2-set-default 'CentOS Linux (4.4.180) 7 (Core)'
grub2-set-default 'CentOS Linux (3.10.0-957.12.1.el7.x86_64) 7 (Core)'
grub2-set-default 'CentOS Linux (3.10.0-957.12.2.el7.x86_64) 7 (Core)'

3. 查看修改后的结果
grub2-editenv list 
4. 重启系统
sudo reboot
```
# 安装linux源码
```
yum install kernel-headers

查看系统安装对应内核的包
rpm -qa | grep kernel
使用
yum remove kernel-3.10.0-327.22.2.el7.x86_64
```
# 设置系统ld路径
```
在/etc/ld.so.conf文件中写入openssl库文件的搜索路径（我的是64位的Centos7.3,所以这里是lib64）
echo "/usr/local/lib64" >> /etc/ld.so.conf
使修改后的/etc/ld.so.conf生效，就应该可以了
ldconfig -v

或者
export LD_LIBRARY_PATH=/home/ych/lib:$LD_LIBRARY_PATH
```
# 创建登陆用户
```
adduser ych
passwd ych
```
# 删除系统存在的用户
```
userdel -r ych
```

# centos升级最新的svn版本
```
yum erase subverson
yum clean all

vim /etc/yum.repos.d/wandisco-svn.repo
[WandiscoSVN]
name=Wandisco SVN Repo
baseurl=http://opensource.wandisco.com/centos/7/svn-1.9/RPMS/$basearch/
enabled=1
gpgcheck=0

yum install subversion
```
# 修改系统grub参数
```
/etc/default/grub
grub2-mkconfig -o /boot/grub2/grub.cfg

ubuntu: update-grub
reboot

default_hugepagesz=1G hugepagesz=1G hugepages=12
default_hugepagesz=2M hugepagesz=2M hugepages=4096
GRUB_CMDLINE_LINUX="crashkernel=auto rhgb quiet default_hugepagesz=1G hugepagesz=1G hugepages=12 iommu=pt intel_iommu=on"
GRUB_CMDLINE_LINUX="crashkernel=auto rhgb quiet default_hugepagesz=1G hugepagesz=1G hugepages=12 hugepagesz=2M hugepages=512 iommu=pt intel_iommu=on"
GRUB_CMDLINE_LINUX="crashkernel=auto rhgb quiet default_hugepagesz=2M hugepagesz=2M hugepages=2048 iommu=pt intel_iommu=on"
```
# 配置系统巨页，改配置文件
```
cp -a /etc/sysctl.conf /etc/sysctl.conf.bak
echo 'vm.nr_hugepages=1024' >> /etc/sysctl.conf
sysctl -p
```
# 开启iommu
```
igb_uio driver must have iommu=pt
vfio-pci driver must have iommu=pt intel_iommu=on

egrep '(vmx|svm)' /proc/cpuinfo
```
# 查看系统安装了多少驱动，每个驱动的信息
```
ll /sys/module/
```
# 安装tftp server
```
yum install -y tftp-server xinetd
修改tftp的配置文件
/etc/xinetd.d/tftp
service tftp
{
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /home/ych/tmp/
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
}
server_args -s 是tftpd共享目录
disable 改为no

开启服务
service tftp restart
service xinetd restart

查看69端口
netstat -nlp | grep 69 

tftp客户端

-l FILE Local FILE
-r FILE Remote FILE
-g      Get file
-p      Put file
-b SIZE Transfer blocks of SIZE octets

tftp -l hello -r hello -g 5.5.5.2
```
# 开启关闭NetworkManager
```
NetworkManager是一个在你系统上运行的服务，它容许你简便地设置你的网络连接，尤其是当你需要设置一个无线网络的连接。很不幸地，NetworkManager 缺省是被停用的，因此我们必须启用它。
启用 NetworkManager 服务
首先我们将会设置你的 CentOS 系统在开机时自动启用 NetworkManager。你可以这样做：
chkconfig NetworkManager on
接著我们会引导它，好叫我们不用重新开机便可以应用它：
service NetworkManager start
你果你是在图像环境里（Gnome）完成这个步骤，你的通知本地（一般在 Gnome 面板的右上角）将会显示一个新图示。如果你点击这个图示，你将会看见一个清单，列出所有可以连接的无线网络。
你可能会想在开机时停用你的网络及 wpa_supplicant 服务，因为 NetworkManager 将会为你处理它们。要是这样，你只需执行：
chkconfig network off
chkconfig wpa_supplicant off

service NetworkManager status
service NetworkManager start
service NetworkManager stop

chkconfig network off
service NetworkManager stop

使用 systemctl list-unit-files  查看开机启动项
systemctl stop kubelet.service 
systemctl stop kube-proxy.service
systemctl stop docker-cleanup.service
systemctl stop docker-storage-setup.service
systemctl stop docker.service
```
# 更新时区(亚洲-中国-上海)
```
sudo timedatectl set-timezone Asia/Shanghai
将硬件时钟调整为与系统时钟一致
sudo timedatectl set-local-rtc 1
```
# linux OOM触发机制
```
linux默认参数vm.min_free_kbytes 64mb，

/proc/sys/vm/min_free_kbytes

该文件表示强制Linux VM最低保留多少空闲内存（Kbytes）。

当可用内存低于这个参数时，系统开始回收cache内存，以释放内存，直到可用内存大于这个值。

vm.min_free_kbytes=409600;
vm.vfs_cache_pressure=200;
vm.swappiness=40。
调整MIN_FREE_KBYTES的目的是保持物理内存有足够的空闲空间，防止突发性的换页。

swapiness缺省为60，减少swapiness会使系统尽快通过swapout不使用的进程资源来释放更多的物理内存。

vfs_cache_pressure的缺省值是100，加大这个参数设置了虚拟内存回收directory和i-node缓冲的倾向，这个值越大，回收的倾向越严重。调整这3个参数的目的就是让操作系统在平时就尽快回收缓冲，释放物理内存，这样就可以避免突发性的大规模换页。
```
# 合代码添加msg实现换行
```
svn ci -m $'xxxxxxxxxxxxxxxxxx\n
1、xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \n
2、xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \n'
```
# 内核模块自动安装方式：
https://wiki.archlinux.org/index.php/Kernel_modules_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)
# 配置命名空间ns
```
ip netns add ns0
ip link set netns ns0 dev enp66s0f1
ip netns exec ns0 bash
```
# top指定进程名
```
top -H -p $(pgrep sample)
```
# 配置系统crash
```
安装kdump：
yum search kexec-tools
yum install kexec-tools.x86_64

配置kdump：
vim  /boot/grub/menu.lst：  设置crashkernel=auto
vim /etc/kdump.conf：          path /var/crash    （core文件产生的目录）

启动kdump：
service kdump start

安装：yum search crash
yum install  crash.x86_64
安装kernel-debuginfo

Command line: BOOT_IMAGE=/boot/vmlinuz-3.10.0-862.3.3.el7.x86_64
wget http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-862.3.3.el7.x86_64.rpm
wget http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-3.10.0-862.3.3.el7.x86_64.rpm

安装：
rpm -ivh kernel-debuginfo-common-x86_64-3.10.0-862.3.3.el7.x86_64.rpm
rpm -ivh x86_64/kernel-debuginfo-3.10.0-862.3.3.el7.x86_64.rpm

分析vmcore
1 模拟机内内核奔溃
echo c > /proc/sysrq-trigger
执行此命令内核崩溃，会在/var/crash目录下生成vmcore文件。（vim /etc/kdump.conf； path /var/crash）
2 分析vmcore
进入目录/var/crash/127.0.0.1-2014-02-24-09:30:19，可以看到vmcore文件。
执行/usr/bin/crash /usr/lib/debug/usr/lib/modules/3.10.0-862.11.6.el7.x86_64/vmlinux  vmcore
具体分析过程见：https://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/index.html?ca=drs


1. 修改  /etc/default/grub
2. 这个参数  crashkernel=auto 改为 crashkernel=512M
3. 然后执行  grub2-mkconfig -o /boot/grub2/grub.cfg
```
#删除内核启动项
```
cd /boot
rm -rf *3.10.0-123.4.4.el7*                     删除所有相关的文件
cd /lib/modules/
rm -rf 3.10.0-123.4.4.el7   对应的文件夹
最后 
grub2-mkconfig -o /boot/grub2/grub.cfg 
一般新内核在grub的list最高位所以直接
grub2-set-default 0
重启 一般就可以了
现在的版本以上操作完成后centos7的内核版本

rm -rf /boot/*4.4.180*
rm -rf /lib/modules/*4.4.180*
rm -rf /boot/*3.10.0.old*
rm -rf /lib/modules/*3.10.0.old*
rm -rf /boot/*3.10.0.old*
rm -rf /lib/modules/*3.10.0.old*

rm -rf config-3.10.0-957.el7.x86_64
rm -rf initramfs-3.10.0-957.el7.x86_64.img
rm -rf initramfs-3.10.0-957.el7.x86_64kdump.img
rm -rf symvers-3.10.0-957.el7.x86_64.gz
rm -rf System.map-3.10.0-957.el7.x86_64
rm -rf vmlinuz-3.10.0-957.el7.x86_64
rm -rf /lib/modules/3.10.0-957.el7.x86_64
```

# 查看网口pcie信息
```
lspci -n |grep -i 42:00.0
sudo lspci -n -d 177d:0011 -vvv |grep -i width
```
# linux 查询yum install安装软件的路径 rpm命令
```
＃[搜索指定rpm包是否安装]--all搜索*httpd*
rpm -qa | grep httpd　
＃[删除一个rpm包]--erase　　　
rpm -e file.rpm     
#通过yum安装的软件包，可以通过 rpm -ql 软件包名来查询这个软件包具体都复制到了哪些文件到哪些地方。

sudo yum erase
使用这个命令卸载软件
```
# centos增加脚本到系统自启动
```
1、将脚本移动到/etc/rc.d/init.d目录下
mv autostart.sh /etc/rc.d/init.d
2、增加脚本的可执行权限
chmod +x autostart.sh
3、添加脚本到开机自动启动项目中
cd /etc/rc.d/init.d
chkconfig --add autostart.sh
chkconfig autostart.sh on

启动脚本里面需要增加以下信息:
添加下面两句到 #!/bin/bash 之后。

# chkconfig: 2345 10 90 
# description: myservice ....
其中2345是默认启动级别，级别有0-6共7个级别。

　　等级0表示：表示关机 　　

　　等级1表示：单用户模式 　　

　　等级2表示：无网络连接的多用户命令行模式 　　

　　等级3表示：有网络连接的多用户命令行模式 　　

　　等级4表示：不可用 　　

　　等级5表示：带图形界面的多用户模式 　　

　　等级6表示：重新启动

10是启动优先级，90是停止优先级，优先级范围是0－100，数字越大，优先级越低。
```
# centos下下载指定命令的源码包
```
下面下载ping的源码包，首先先使用rpm命令查看ping的安装包名称
$rpm -qf `which ping`
iputils-20160308-10.el7.x86_64

下载
$yumdownloader --source iputils-20160308-10.el7.x86_6
iputils-20160308-10.el7.src.rpm 

从rpm格式包中提取源码:
rpm2cpio iputils-20160308-10.el7.src.rpm|cpio -id

yum install scsi-target-utils-1.0.55-4.el7.x86_64 --downloadonly
yumdownloader scsi-target-utils
```
# 查询gcc相关宏定义
```
gcc -posix -E -dM - </dev/null
_BYTE_ORDER

_MIPS_ARCH
_ARCH_PPC64
__x86_64__
```
# linux批量替换指定文件夹中所有文件（包括文件夹名、文件名、文件内容）的指定内容
```
1、批量替换指定多个文件的文件内容
在指定目录/your/path里，查找包含old_string字符串的所有文件，并用new_string字符串替换old_string字符串。
sed -i "s/old_string/new_string/g"  `grep old_string -rl /your/path`  

2、批量修改指定多个文件的文件名
在指定的路径/your/path下，查找以old_name字符串开头的所有文件，并以new_string替换掉old_string字符串。 
find /your/path -name 'old_name*' | xargs -i echo mv \"{}\" \"{}\" | sed 's/old_name/new_name/2g' | sh  
实例：
find $PWD -name '\[www.java1234.com\]*' | xargs -i echo mv \"{}\" \"{}\" | sed 's/\[www.java1234.com\]/""/2g' | sh
说明：xargs提取查找的内容为参数，-i用于{}的提取，并提取到到指定变量{}，echo是为了纯文本输出后面的mv命令，其中{}为变量，sed命令为文本编辑命令，其中可以执行s的替换，后面2g表示替换第二个匹配项。在使用时注意路径的空格和字符串转义。
```
# 设置指定用户到vpp组
```
‘vpp’ Usergroup
When VPP is installed, a new usergroup ‘vpp’ is created. To avoid running the VPP CLI (vppctl) as root, add any existing users to the new group that need to interact with VPP:

$ sudo usermod -a -G vpp user1
Update your current session for the group change to take effect:

$ newgrp vpp
```
# grep用法
忽略匹配二进制文件
```
grep "external" ./ -nr --binary-files=without-match
```
全词匹配,不加-w就是模糊匹配
```
grep -w "abc" # 结果为abc
```
# shell常用脚本命令
```
-e filename 如果 filename存在，则为真
-d filename 如果 filename为目录，则为真 
-f filename 如果 filename为常规文件，则为真
-L filename 如果 filename为符号链接，则为真
-r filename 如果 filename可读，则为真 
-w filename 如果 filename可写，则为真 
-x filename 如果 filename可执行，则为真
-s filename 如果文件长度不为0，则为真
-h filename 如果文件是软链接，则为真
filename1 -nt filename2 如果 filename1比 filename2新，则为真。
filename1 -ot filename2 如果 filename1比 filename2旧，则为真。

if [[ "$str1" =~ "a" ]] || [[ "$str2" =~ "b" ]] || [[ "$str3" =~ "c" ]] || [[ "$str4" =~ "d" ]]; then
    echo "yes"
else
    echo "no"
fi

一、逻辑运算符 

逻辑卷标	表示意思
1.	关于档案与目录的侦测逻辑卷标！
-f	常用！侦测『档案』是否存在 eg: if [ -f filename ]
-d	常用！侦测『目录』是否存在
-b	侦测是否为一个『 block 档案』
-c	侦测是否为一个『 character 档案』
-S	侦测是否为一个『 socket 标签档案』
-L	侦测是否为一个『 symbolic link 的档案』
-e	侦测『某个东西』是否存在！
2.	关于程序的逻辑卷标！
-G	侦测是否由 GID 所执行的程序所拥有
-O	侦测是否由 UID 所执行的程序所拥有
-p	侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）
3.	关于档案的属性侦测！
-r	侦测是否为可读的属性
-w	侦测是否为可以写入的属性
-x	侦测是否为可执行的属性
-s	侦测是否为『非空白档案』
-u	侦测是否具有『 SUID 』的属性
-g	侦测是否具有『 SGID 』的属性
-k	侦测是否具有『 sticky bit 』的属性
4.	两个档案之间的判断与比较 ；例如[ test file1 -nt file2 ]
-nt	第一个档案比第二个档案新
-ot	第一个档案比第二个档案旧
-ef	第一个档案与第二个档案为同一个档案（ link 之类的档案）
5.	逻辑的『和(and)』『或(or)』
&&	逻辑的 AND 的意思
||	逻辑的 OR 的意思


整数变量表达式
-eq 等于
-ne 不等于
-gt 大于
-ge 大于等于
-lt 小于
-le 小于等于


字符串变量表达式
If  [ $a = $b ]                 如果string1等于string2，则为真
                                字符串允许使用赋值号做等号
if  [ $string1 !=  $string2 ]   如果string1不等于string2，则为真       
if  [ -n $string  ]             如果string 非空(非0），返回0(true)  
if  [ -z $string  ]             如果string 为空，则为真
if  [ $sting ]                  如果string 非空，返回0 (和-n类似) 


    逻辑非 !                   条件表达式的相反
if [ ! 表达式 ]
if [ ! -d $num ]               如果不存在目录$num


    逻辑与 –a                   条件表达式的并列
if [ 表达式1  –a  表达式2 ]


    逻辑或 -o                   条件表达式的或
if [ 表达式1  –o 表达式2 ]

    
SYSTEM=`uname -s`    #获取操作系统类型，我本地是linux
if [ $SYSTEM = "Linux" ] ; then     #如果是linux的话打印linux字符串
echo "Linux" 
elif [ $SYSTEM = "FreeBSD" ] ; then   
echo "FreeBSD" 
elif [ $SYSTEM = "Solaris" ] ; then 
echo "Solaris" 
else 
echo "What?" 
fi     #ifend


i=0
for pcieid in 04:00.0 04:00.1 04:00.2 04:00.3
do 
    echo pcie_$i is $pcieid
	i=$(($i+1))
done 


TMP=`lspci |grep Eth | awk '{print $1}'`

i=0
for pcieid in $TMP
do 
    echo pcie_$i is $pcieid
	i=$(($i+1))
done 

#!/bin/bash

while true
do

done
```

# 开启nfs
```
修改NFS配置文件,定义共享
[root@linuxidc ~]#vi /etc/exports
定义向所有客户端共享/share目录,共享方式为可读可写
[root@linuxidc ~]#cat /etc/exports
/home/ych *(rw,sync)

开启nfs服务
systemctl restart nfs
systemctl status nfs
查看exportfs
```
# exportfs 
/home/ych     	<world>
```
客户机直接mount即可
sudo mount 10.154.102.227:/home/ych /home/ych/mount
```



# 设置系统时间
```
date -s 20/07/2019
date -s 15:00:00

date -s "2019-7-20 15:01:00"

hwclock -w
```

# 格式化、挂载磁盘
https://www.cnblogs.com/myvic/p/6816924.html

mount -t ext3 /dev/sda1 mount

# centos增加自编译内核模块到系统开机自动安装
```
1.拷贝ko到指定的内核模块路径
mkdir -p /lib/modules/$(uname -r)/kernel/drivers/net/ethernet/intel/e1000e
cp -a /root/AF8.0.12/module/e1000e-2.0.0.1/src/e1000e.ko /lib/modules/$(uname -r)/kernel/drivers/net/ethernet/intel/e1000e/
2.修改内核模块安装路径依赖
depmod -a
3.重启系统即可
reboot
```

# 生成和打patch
```
给修改过的内核生成patch，然后用生成的patch给未修改过的内核打补丁
其中，目录linux-2.6.31.3为未修改过的内核，目录linux-2.6.31.3_1为修改过的内核
diff -uparN linux-2.6.31.3 linux-2.6.31.3_1/ > mypatch
cd linux-2.6.31.3
patch -p1 < mypatch
```

# 通过find命令找到的文件拷贝到一个新的目录
```
将通过find命令找到的文件拷贝到一个新的目录中 
有这样的一个需求，需要将一部分符合条件的文件从一个目录拷贝到另一个目录中，我通过find命令从源目录查找到符合条件的文件然后使用cp命令拷贝到目标目录： 
方法一 
命令如下： 
find src_dir -name "access.log.2011102[2-6]*" -exec cp {} dst_dir \; 
拷贝文件到远程主机上的目标目录的命令： 
find src_dir -name "access.log.2011102[2-6]*" -exec scp {} 用户名@主机ip:dst_dir \; 
方法二 
find src_dir -name "access.log.2011102[2-6]*" |xargs -i cp {} dst_dir 
或 
find src_dir -name "access.log.2011102[2-6]*" |xargs -I {} cp {} dst_dir 
拷贝文件到远程主机上的目标目录的命令： 
find src_dir -name "access.log.2011102[2-6]*" |xargs -i scp {} 用户名@主机ip:dst_dir 
或 
find src_dir -name "access.log.2011102[2-6]*" |xargs -I {} scp {} 用户名@主机ip:dst_d

find /data/AF8.0.11.zx/module -name "*.ko" |xargs -i cp {} /data/work/test_ko 

```

# ssh scp免密执行命令
```
sshpass -p "password" cmd
用以上命令执行需要密码的命令，就不用手动输入了

sshpass -p " " scp ych@200.200.153.18:/home/ych/AF8.0.11.zx/kernel-3.10.0/net/core/dev.c /data/AF8.0.11.zx/kernel-3.10.0/net/core/dev.c
```

# dos2unix整个目录
```
find . -type f -exec dos2unix {} \;
```

# 一直循环报错：file“xxxxx”has modification times xxxxx s in the future..
```
find /your/dir -type f -exec touch {} +
```

# syslog打印
```
#include <syslog.h>

syslog(LOG_INFO, "ych:%s(%d) ", __FUNCTION__, __LINE__);
```

# AF 内核打印
```
int g_ych_debug[NR_CPUS] = {0};

extern int g_ych_debug[NR_CPUS];
#define YCH_LOG(fmt, arg...)                                  \
do                                                            \
{                                                             \
    if (g_ych_debug[smp_processor_id()] == 1)                                     \
        printk("ych:%s(%d) "fmt, __FUNCTION__, __LINE__, ##arg);  \
}                                                             \
while((0))

#define YCH_LOG(mpkt, fmt, arg...)                                  \
do                                                            \
{                                                             \
    if (!strcmp(((struct mid_packet *)mpkt)->dev->name, "eth10") || \
		!strcmp(((struct mid_packet *)mpkt)->dev->name, "eth11") || \
		!strcmp(((struct mid_packet *)mpkt)->dev->name, "eth12") || \
		!strcmp(((struct mid_packet *)mpkt)->dev->name, "eth13")) \
        printk("ych:%s(%d) "fmt"\r\n", __FUNCTION__, __LINE__, ##arg);  \
}                                                             \
while((0))


#define YCH_LOG(mpkt, fmt, arg...)                                  \
do                                                            \
{                                                             \
}                                                             \
while((0))
```

# perf使用命令
1. perf无法找到外部模块符号
必须使它成为一个内核模块,然后perf可以找到它的符号
```
IN_TREE_DIR=/lib/modules/`uname -r`/kernel/modulename
mkdir -p $IN_TREE_DIR
cp modulename.ko $IN_TREE_DIR
depmod -a
```
2. record和report命令
perf top
perf record -a -e cycles -o cycle.perf -g sleep 10
perf record -C 0 -e cycles -o cycle.perf -g sleep 20
perf record -C 7 -e cycles -o cycle.perf -g sleep 10
perf record -C 8 -e cycles -o cycle.perf -g sleep 10
perf record -C 9 -e cycles -o cycle.perf -g sleep 10
perf record -C 10 -e cycles -o cycle.perf -g sleep 10
perf record -C 11 -e cycles -o cycle.perf -g sleep 10
perf record -C 6,7,8,9,10,11 -e cycles -o cycle.perf -g sleep 10

perf report -i nginx_http_zlib_2KB_6worker_core4.perf | more
perf report -i nginx_http_6worker_core4_nozip_ssl_nooffload.perf | more
perf report -i cycle.perf | more

# centos配置本地光盘yum源
1. 将本地ios磁盘挂载到系统，这里我的挂载路径在 
```
   /run/media/ych/CentOS-8-BaseOS-x86_64
```
2. 备份系统yum配置文件  
```
   cp -a /etc/yum.repos.d /etc/yum.repos.d_bak
```
3. 删除不用的repo文件
```
   cd /etc/yum.repos.d
   保留CentOS-Media.repo其他repo全部删除
```
4. 修改CentOS-Media.repo文件
改动前:
```
[c8-media-BaseOS]
name=CentOS-BaseOS-$releasever - Media
baseurl=file:///media/CentOS/BaseOS
        file:///media/cdrom/BaseOS
        file:///media/cdrecorder/BaseOS
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial

[c8-media-AppStream]
name=CentOS-AppStream-$releasever - Media
baseurl=file:///media/CentOS/AppStream
        file:///media/cdrom/AppStream
        file:///media/cdrecorder/AppStream
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
```
改动后:
```
[c8-media-BaseOS]
name=CentOS-BaseOS-$releasever - Media
baseurl=file:///run/media/ych/CentOS-8-BaseOS-x86_64/BaseOS
        #file:///media/cdrom/BaseOS
        #file:///media/cdrecorder/BaseOS
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial

[c8-media-AppStream]
name=CentOS-AppStream-$releasever - Media
baseurl=file:///run/media/ych/CentOS-8-BaseOS-x86_64/AppStream
        #file:///media/cdrom/AppStream
        #file:///media/cdrecorder/AppStream
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
```

# 修改centos sudoers文件，让指定用户sudo免密码
1. 使用su/su - 命令进入root权限下
2. 给/etc/sudoers文件添加写权限 chmod u+w /etc/sudoers
3. 找到“root ALL=(ALL) ALL ”，在后面添加："ych ALL=(ALL)  NOPASSWD:  ALL"
4. 去掉 “# %wheel	ALL=(ALL)	NOPASSWD: ALL” 这行前面的注释
5. 保存退出，并将/etc/sudoers文件写权限去掉，chmod u-w /etc/sudoers

# centos7搭建gitlab服务器
1. 安装 policycoreutils-python
```
	yum install -y policycoreutils-python
```
2. 下载gitlab rpm包
```
    wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-12.4.0-ce.0.el7.x86_64.rpm
```
3. 安装 rpm 包
```
    sudo rpm -i gitlab-ce-12.4.0-ce.0.el7.x86_64.rpm
```
4. 修改gitlab配置文件，指定服务器ip和自定义端口
```
    sudo vim /etc/gitlab/gitlab.rb

## GitLab URL
##! URL on which GitLab will be reachable.
##! For more details on configuring external_url see:
##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab
external_url 'http://200.200.232.200:1234'	
```
5. 重置并启动GitLab
```
gitlab-ctl reconfigure;gitlab-ctl restart
```

6. 登录gitlab
http://200.200.232.200:1234
初始账户: root 密码:5iveL!fe

7. 设置gitlab开机自启动
```
启用 Gitlab 开机自启动：
systemctl enable gitlab-runsvdir.service
禁止 Gitlab 开机自启动：
systemctl disable gitlab-runsvdir.service
```
# yum 安装nginx
```
sudo yum install -y nginx

sudo systemctl start nginx.service
sudo systemctl enable nginx.service
```
# yum 安装Apache httpd
```
sudo yum install -y httpd-devel

sudo systemctl start httpd.service
sudo systemctl enable httpd.service

html目录在 /var/www/html
```

#centos下关闭自动锁屏
自己这段时间在学习Linux，选用的系统的为CentOS，在实际操作过程中遇到问题，在无任何操作情况下，系统过一段时间自动锁屏需要重新输入密码。经过多次尝试以后终于成功！解决方法如下：

Settings=>Privacy=>Screen Lock 这里需要选择off;

Setting=>Power=>Dim screen when inactiv选择off;

Setting=>Power=>Blank screen选择Never。该选项为屏幕一段时间自动息屏，按Enter即可进入，不需输入密码。

这样的话，就不会出现自动锁屏的情况。

# nginx配置https
1.生成证书
```
cd /etc/nginx
mkdir key
cd key

带密码：
openssl genrsa -des3 -out xxx.key 2048
openssl rsa -in xxx.key -out ssl.key
rm -rf xxx.key
openssl req -new -key ssl.key -out ssl.csr
openssl x509 -req -days 365 -in ssl.csr -signkey ssl.key -out ssl.crt


不带密码:
生成私钥：
openssl genrsa -out rootca.cakey 2048 
生成证书：
openssl req -new -x509 -days 1825 -key rootca.cakey -out rootca.crt 

```

2. 配置nginx文件
```
    server {
        listen       443 ssl http2 default_server;
        listen       [::]:443 ssl http2 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

		ssl_certificate /etc/nginx/key/rootca.crt;
		ssl_certificate_key /etc/nginx/key/rootca.cakey;
        ssl_session_cache shared:SSL:1m;
        ssl_session_timeout  10m;
        ssl_ciphers PROFILE=SYSTEM;
        ssl_prefer_server_ciphers on;

#        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
```

systemctl status nginx.service 
systemctl stop nginx.service 
systemctl start nginx.service 

curl -k https://12.12.12.2

# win7 在git bash里面开启sshd
```
ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key
ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key
ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key
/usr/bin/sshd
```

# 打印ip地址
```
#define NIP2STR(addr)                            \
    ((unsigned char *)&addr)[0],                \
        ((unsigned char *)&addr)[1],            \
        ((unsigned char *)&addr)[2],            \
        ((unsigned char *)&addr)[3]

waf_dbg_1("%u.%u.%u.%u -> %u.%u.%u.%u:%d, all state:%s\n", NIP2STR(statis_node->key.sip),
	NIP2STR(statis_node->key.dip), ntohs(statis_node->key.dport), state2str(statis_node->state));	

```

# centos设置core path
```
echo `pwd`"/%e-core-%s.%p" > /proc/sys/kernel/core_pattern
echo "/home/ych/data/coredump/%e-core-%s.%p" > /proc/sys/kernel/core_pattern
cat /proc/sys/kernel/core_pattern
```

# ps命令汇总
1. 查看进程的运行核
ps -eTF 
PSR列显示数字为运行核id
或者
ps -eo comm,pid,psr

#iperf
iperf3 -s -p 5555
iperf3 -u -c 20.20.20.1 -t 0 -b 1G

# shell命令
## 统计脚本
grep vmalloc /proc/vmallocinfo | awk '{total+=$2}; END {print total}'
## 同时grep多个命令
ps -eo comm,rss |grep -E --color '(apiserver|cfg-center|api-midware|auth-server|afapi-service|cfg_notify|sfos-proxy)'

# grep 排除目录
```
grep -rni 'http' --exclude-dir={.git,res,bin} ./
```

# 使用linux kernel一样的clang format格式化自己的代码
1. centos安装：clang
`yum install clang`
2. 下载内核的.clang-format
`https://github.com/torvalds/linux/edit/master/.clang-format`
3. 把放到转化文件的当前目录下，直接使用命令对代码进行格式化
`clang-format -i helloworld.c`
`find ./ -name "*.c" |xargs -i clang-format -i {}`

# 打印以太网报文
```

static inline int ngbe_dump_pkt(const char *buf, int len)
{
	struct ethhdr *prot_eth;

	return 0;
	if (!buf || len < 0) {
		printk("input para err \r\n");
		return -1;
	}

	prot_eth = buf;
	
	if (prot_eth->h_dest[0] & 0x01)
		return -1;

	printk("buf:%p, len:%d \r\n", buf, len);
	
	printk("	     dhost=%02x:%02x:%02x:%02x:%02x:%02x\n",
	      prot_eth->h_dest[0], prot_eth->h_dest[1],
	      prot_eth->h_dest[2], prot_eth->h_dest[3],
	      prot_eth->h_dest[4], prot_eth->h_dest[5]);
	printk("	     shost=%02x:%02x:%02x:%02x:%02x:%02x\n",
	      prot_eth->h_source[0], prot_eth->h_source[1],
	      prot_eth->h_source[2], prot_eth->h_source[3],
	      prot_eth->h_source[4], prot_eth->h_source[5]);
	printk("	     ether_type=%04x\n", ntohs(prot_eth->h_proto));

	if (prot_eth->h_proto == __constant_htons(ETH_P_IP)) {
		printk("	       -> it's ETHERTYPE_IP!\n");
		struct iphdr *iphdr = (typeof(iphdr))(prot_eth + 1);
		u8 *src = (void *)&iphdr->saddr;
		u8 *dst = (void *)&iphdr->daddr;
		printk("		  ver=%d,ihl=%d,tos=%d,len=%d,id=%d\n",
			iphdr->version, iphdr->ihl, iphdr->tos, ntohs(iphdr->tot_len),
			ntohs(iphdr->id));
		printk("		  frag_off=%d,ttl=%d,prot=%d,csum=0x%04x\n",
			ntohs(iphdr->frag_off), iphdr->ttl, iphdr->protocol,
			ntohs(iphdr->check));
		printk("		  src=%d.%d.%d.%d\n",
			src[0], src[1], src[2], src[3]);
		printk("		  dst=%d.%d.%d.%d\n",
			dst[0], dst[1], dst[2], dst[3]);

		if (iphdr->protocol == IPPROTO_TCP) {
			struct tcphdr   *tcph = NULL;
			tcph = (struct tcphdr *)((char *)iphdr + iphdr->ihl*4);

			printk("source:%d, dest:%d, syn:%d, fin:%d, ack:%d, seq:%ld\n", 
				ntohs(tcph->source), ntohs(tcph->dest), 
				tcph->syn, tcph->fin, tcph->ack, ntohl(tcph->seq));

			return 0;
		}
	}

	return -1;
}

#include <ctype.h>
static inline void __dump_raw_data(const unsigned char *data, int len) 
{
	char buf[160];
	int offset = 0;

	LPS_PRINT_DEBUG("data:%p, len:%d", data, len);

	while (offset < len) {
		int i;

		snprintf(buf, sizeof(buf), "%08x", offset);
		strncat(buf + strlen(buf), "  ", sizeof(buf)-1);

		i = 0;
		while (i < 8) {
			if (offset + i < len) {
				snprintf(buf + strlen(buf), sizeof(buf), "%02x ", data[offset + i]);
			} else {
				strncat(buf + strlen(buf), "   ", sizeof(buf)-1);
			}

			i++;
		}

		strncat(buf + strlen(buf), " ", sizeof(buf)-1);

		i = 8;
		while (i < 16) {
			if (offset + i < len) {
				snprintf(buf + strlen(buf), sizeof(buf), "%02x ", data[offset + i]);
			} else {
				strncat(buf + strlen(buf), "   ", sizeof(buf)-1);
			}

			i++;
		}

		strncat(buf + strlen(buf), " |", sizeof(buf)-1);

		i = 0;
		char *p = buf + strlen(buf);
		while ((offset + i < len) && (i < 16)) {
			int c = data[offset + i];

			if (isprint(c)) {
				*p++ = c;
			} else {
				*p++ = '.';
			}

			i++;
		}

		*p++ = '|';

		LPS_PRINT_DEBUG("%s", buf);
		offset += 16;
	}
}
```

# centos 安装使用fragroute
1. 官网 https://www.monkey.org/~dugsong/fragroute/
2. wget https://www.monkey.org/~dugsong/fragroute/fragroute-1.2.tar.gz
3. wget https://github.com/downloads/libevent/libevent/libevent-1.4.14b-stable.tar.gz
4. wget https://nchc.dl.sourceforge.net/project/libdnet/libdnet/libdnet-1.11/libdnet-1.11.tar.gz
5. wget http://www.tcpdump.org/release/libpcap-1.10.0.tar.gz
6. fragroute/libevent/libdnet/libpcap 的编译安装都是
./configure;make;make install
7. fragroute 配置文件 /home/ych/fragroute-1.2/fragroute.conf
8. 使用教程 https://blog.csdn.net/weixin_34037515/article/details/93001704
https://www.kancloud.cn/haoyuanqiang/kali_linux_tools_documents/1060363








